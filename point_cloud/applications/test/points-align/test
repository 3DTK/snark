#!/bin/bash

readonly scriptname=$( basename $0 )

source $( type -p comma-name-value-util ) || { echo "$scriptname: cannot source 'comma-name-value-util'" >&2; exit 1; }

function random_cloud
{
    # Unless seeded with srand(), rand() will always give the same sequence
    gawk -v num_points=$1 -v l=$2 -v w=$3 -v h=$4 '
    function r(min,max) { return rand()*(max-min)+min; }
    BEGIN {
        for( i = 0; i < num_points; i++)
            printf( "%f,%f,%f\n", i / num_points * l, r( -w, w ), r( -h, h ));
    }'
}

function pair_fields
{
    echo $( echo $1 | csv-fields prefix --path "first" ),$( echo $1 | csv-fields prefix --path "second" )
}

function max_diff
{
    paste -d, $1 $2 \
        | csv-shuffle --fields $( pair_fields $fields ) --output $( pair_fields x,y,z ) \
        | points-calc subtract \
        | csv-shuffle --fields $( points-calc subtract --input-fields),$( points-calc subtract --output-fields ) \
                      --output $( points-calc subtract --output-fields ) \
        | points-calc norm \
        | csv-shuffle --fields $( points-calc norm --input-fields),$( points-calc norm --output-fields ) \
                      --output $( points-calc norm --output-fields ) \
        | csv-calc max --format=d
}

function perturb
{
    local perturbation=$1
    if [[ -z $perturbation ]]; then
        cat
    else
        gawk -v p=$perturbation '
        function r(min,max) { return rand()*(max-min)+min; }
        function perturb(x,p) { f = r(1-p,1+p); return x*f; }
        BEGIN { FS=","; OFS=","; OFMT="%.12f"; }
        { for( i=1; i<=NF; i++ ) $i = perturb( $i, p ); print }
        '
    fi
}

[[ $1 == "--view" ]] && { options_view=1; shift; }

output_dir=output
[[ -d $output_dir ]] || mkdir $output_dir
cd $output_dir

fields="x,y,z"

comma_path_value_to_var

if [[ $reference =~ "random" ]]; then
    num_points=${reference#random }
    random_cloud $num_points 100 10 10 > reference.csv
else
    echo -e $reference > reference.csv
fi

# Treat displacement and rotation as vectors to convert from degrees to radians
scalar=$( echo "3.14159265359 / 180" | bc -l )
frame_format=u/x,u/y,u/z,v/x,v/y,v/z
frame=$( echo $frame,$scalar | points-calc scale --fields=$frame_format,scalar \
             | csv-shuffle --fields=$frame_format,scalar,x,y,z \
                           --output=u/x,u/y,u/z,x,y,z )

cat reference.csv | points-frame --to $frame --fields=$fields > pure_source.csv
cat pure_source.csv | perturb $perturbation > source.csv

pasted_fields=$( pair_fields $fields )
combined_fields=$( echo $pasted_fields | csv-fields cut --fields second/block )

paste -d, reference.csv source.csv \
    | csv-shuffle --fields=$pasted_fields --output=$combined_fields \
    > combined.csv

combined_fields=$( echo $combined_fields | csv-fields rename --fields first/block --to block )

binary_transform=cat
binary_option=
[[ $mode == "binary" ]] && { binary_transform="csv-to-bin 6d"; binary_option="--binary=6d"; }

transform_with_error=$( cat combined.csv | $binary_transform \
    | points-align $binary_option --fields=$combined_fields --output-error )
echo "exit_code=$?"

transform=$( echo $transform_with_error \
    | csv-shuffle --fields $( points-align --output-fields --output-error --fields=$combined_fields ) \
                  --output $( points-align --output-fields ) )

cat source.csv | points-frame --from $transform --fields=$fields > recreated.csv

echo -e "$transform_with_error" \
    | name-value-from-csv $( points-align --output-fields --output-error --fields=$combined_fields ) --prefix transform --line-number\
    | csv-quote --delimiter='=' --fields=,value

echo "max_error=$( max_diff reference.csv recreated.csv )"

(( options_view )) && view-points "reference.csv;colour=red" "source.csv;colour=yellow" "recreated.csv;colour=green"
exit 0
