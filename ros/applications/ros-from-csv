#!/usr/bin/python

import argparse, sys
from signal import signal, SIGPIPE, SIG_DFL
import rospy, rostopic
import comma.csv
import snark.ros.convert
from snark.ros.command_line import *

help_description = """

take csv records on stdin, publish on a given ros topic

todo: fix binary (currently only ascii mode works)

todo: load message type from .msg file

"""

help_examples = """

examples
    forward ros messages (e.g. to illustrate the principle or debug), start with trying --dry-run
        forward with buffering
            ros-to-csv some-topic | ros-from-csv some-topic
        forward without buffering
            ros-to-csv some-topic | ros-from-csv some-topic --flush
        print to stdout
            ros-to-csv some-topic | ros-from-csv some-topic --flush --dry-run
        
    using message types offline, try it
        imply package from message type
            echo 1,2,3 | ros-from-csv --type geometry_msgs.msg.Point --dry
        explicitly specify package with message type definition
            echo 1,2,3 | ros-from-csv --import geometry_msgs.msg --type geometry_msgs.msg.Point --dry

"""

def main():
    parser = argparse.ArgumentParser( description = help_description, epilog = help_examples, formatter_class = argparse.RawDescriptionHelpFormatter, conflict_handler = 'resolve' )
    parser.add_argument( 'topic', nargs = '?', help = 'topic', type = str )
    parser.add_argument( '--dry-run', '--dry', help = 'output messages to stdout, do not send to topic', action = 'store_true' )
    parser.add_argument( '--message-type', '--type', help = 'message type, useful for debugging', type = str )
    parser.add_argument( '--output-fields', help = 'output input csv fields and exit', action = 'store_true' )
    parser.add_argument( '--package', '--import', help = 'if --type specified, package to import', type = str )
    parser.add_argument( '--ros-queue-size', '--ros-queue', '--queue-size', '--queue', default = 1, help = 'chat more', type = int )
    parser.add_argument( '--verbose', '-v', help = 'chat more', action = 'store_true' )
    comma.csv.add_options( parser )
    # to override format and binary
    remove_argparse_options( parser, [ '-b', '--binary', '--format' ] )
    group = parser.add_mutually_exclusive_group()
    group.add_argument( '--format', help='in ascii mode, format hint string containing the types of the input csv data', type=str )
    group.add_argument( '-b', '--binary', help='in binary mode, format string containing the types of the input csv data', type=str )
    args = parser.parse_args()
    signal( SIGPIPE, SIG_DFL ) # do no want the IOError message trace
    if args.dry_run:
        import numpy
        numpy.set_printoptions( linewidth=numpy.inf, threshold=numpy.inf, precision=args.precision and args.precision or numpy.get_printoptions()['precision'] )
    if not args.message_type is None:
        package = '.'.join( args.message_type.split( '.' )[:-1] ) if args.package is None else args.package
        if len( package ) > 0: exec( 'import ' + package )
    if args.topic is None and not args.dry_run and args.type is None: print >> sys.stderr, "ros-from-csv: please specify --topic"; sys.exit( 1 )
    if args.message_type is None: message_type = rostopic.get_topic_class( args.topic )[0]
    else: exec( 'message_type = ' + args.message_type )
    message = message_type()
    record_type, record_ctor = snark.ros.convert.ros_message_to_csv_record( message_type() )
    if args.format or args.binary:
        formats = args.format and args.format or args.binary
        fields = args.fields and args.fields or record_type.fields
        lengths = lengths_of_strings( fields, formats )
        record_type, record_ctor = snark.ros.convert.ros_message_to_csv_record( message_type(), lengths )
    if args.output_fields: print ','.join( record_type.fields ); sys.exit( 0 )
    #istream = comma.csv.stream( record_type, delimiter = args.delimiter, binary = True, fields = args.fields, default_values = None, flush = args.flush )
    istream = comma.csv.stream( record_type, delimiter = args.delimiter, fields = args.fields, default_values = None, flush = args.flush )
    assign = record_type.assign( message, snark.ros.convert.from_csv_supported_types )
    if args.dry_run:
        if args.verbose: print >> sys.stderr, "ros-from-csv: dry run, printing messages to stdout"
    else:
        publisher = rospy.Publisher( args.topic, message_type, queue_size = args.ros_queue_size )
        rospy.init_node( 'ros_from_csv', anonymous = True )
        if args.verbose: print >> sys.stderr, "ros-from-csv: publishing to topic '%s'..." % args.topic
    for records in istream:
        for record in records: # todo? try assigning the whole array at once? should be a better performance? but we may need to expand comma.csv.struct.assign() to make it working
            assign( record )
            if args.dry_run: print message
            else: publisher.publish( message )

if __name__ == '__main__': main()
