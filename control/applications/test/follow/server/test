#!/bin/bash

function output_commands
{
    local prefix=output/commands
    csv-from-bin $format,$output_format | name-value-from-csv $fields,$output_fields --line-number --prefix $prefix | csv-quote --unquote --fields ,x --delimiter =
    echo "finished outputting commands" >&2
}

function wait_for_control
{
    local dt=0.1
    local -i count=0
    local -i max_count=50
    while ! grep -E ":$waypoints_port\s" &>/dev/null <( netstat -ltn ); do
        sleep $dt
        (( ++count ))
        if (( count > max_count )); then { echo "$scriptname: timed out waiting for control to launch"; return 1; }; fi
    done
}


scriptname=$( readlink -f $0 )
source $( type -p comma-application-util ) || { echo "$scriptname: failed to source comma-application-util" >&2; exit 1; }

config=data/config.json
feedback=data/feedback.csv

comma_path_value_to_var < <( name-value-convert < "$config" )

waypoints_port=10100
feedback_port=${feedback_address##*:} # address is a local tcp port

fields=$( name-value-get waypoints/fields < "$config" | csv-fields prefix --path target )
format=$( name-value-get waypoints/binary < "$config" )

output_format=$( control-follow-waypoints-new --output-format --config="$config" )
output_fields=$( control-follow-waypoints-new --output-fields --config="$config" )

cat "$feedback" | csv-play | csv-to-bin $feedback_binary --flush | io-publish --size $( csv-size $feedback_binary ) tcp:$feedback_port & feedback_pid=$!

{
    control-follow-waypoints-server --port=$waypoints_port --config=$config & server_pid=$!
    wait_for_control || exit 1
    {
        # feedback trajectory is straight from 2,0 via 1,1 to 0,2 ( see data/feedback.csv )
        # fields are x,y,heading_offset,is_absolute,speed,index ( see data/config.json )
        echo 1,1,0.1,1,11.1,0
        echo 0,2,0.1,1,22.2,1
    } | csv-to-bin $waypoints_binary | socat -u - tcp:localhost:$waypoints_port
    sleep 4 # give it enough time to reach the second target waypoint ( about 2 seconds ) but do not wait too long ( the feedback stops in 10 seconds )
    kill $server_pid
    wait $server_pid
    exit
} | output_commands
comma_status_ok || { echo "$scriptname: control pipeline failed" >&2; exit 1; }

kill $feedback_pid
wait $feedback_pid

