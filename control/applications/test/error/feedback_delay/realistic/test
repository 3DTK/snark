#!/bin/bash

function wait_for_port
{
    local port=$1
    local -i count=0
    local listen_state=$( io-ls --enum-state | grep ,LISTEN$ | cut -d, -f1 )
    while ! io-ls --fields local/port,state | grep $port,$listen_state &>/dev/null; do
        sleep 0.1
        if (( ++count > 100 )); then { echo "$scriptname: timed out waiting for port $port"; return 1; }; fi
    done
    echo "port $port is ready" >&2
}

function kill_if_exists
{
    local pid=$1
    local what=$2
    if kill -0 $pid &>/dev/null; then
        echo "killing $what (pid=$pid): $( date +%T.%N )" >&2
        kill $pid
        wait $pid
    fi
}

function bye
{
    kill_if_exists $feedback_pid feedback
    exit
}

trap bye INT HUP TERM EXIT

scriptname=$( readlink -f $0 )
source $( type -p comma-application-util ) || { echo "$scriptname: failed to source comma-application-util" >&2; exit 1; }
source $( type -p comma-process-util ) || { echo "$scriptname: failed to source comma-process-util" >&2; exit 1; }

mkdir -p output

fields=x,y,heading_offset
binary=d,d,d

feedback_fields=t,x,y,yaw
feedback_binary=t,d,d,d

feedback_port=$(( 1024 + $RANDOM ))
feedback_pid=
# feedback runs for about 4 seconds (1 point every 10 milliseconds) with first time stamp at 20150101T000000
# the waypoints are sent after 1 second delay, so first feedback point used by control-error should be around 20150101T000001
# the trajectory goes from 0,0 to 400,0 
# note that control-error outputs errors every 0.05 seconds (--frequency=20)
seq 0 400 \
    | csv-paste value=20150101T000000 - value=0,0 \
    | csv-eval --fields t,i --format t,ui "t+=i*timedelta64(10,'ms')" --flush \
    | csv-play \
    | csv-to-bin $feedback_binary --flush \
    | socat -u - tcp-listen:$feedback_port & feedback_pid=$!
wait_for_port $feedback_port
sleep 0.1 # sleep for a short while to allow the feedback points to become available on tcp port
output_format=$binary,$feedback_binary,$( control-error --output-format --status )
output_fields=$( csv-fields prefix --path target <<< $fields ),$( csv-fields prefix --path feedback <<< $feedback_fields ),$( control-error --output-fields --status )

{
    sleep 1 # wait long enough for control-error to receive a lot of feedback
    echo "sending 1st waypoint at $( date +%T.%N )" >&2
    echo 150,0,0
    sleep 1 # wait before sending second waypoint (note that 1st waypoint is reached at about 1.5 seconds, but 2nd waypoint is only send after 2 seconds)
    echo "sending 2nd waypoint at $( date +%T.%N )" >&2
    echo 250,0,0
    sleep 1 # keep stdin of control-error open for a while
} \
    | csv-to-bin $binary --flush \
    | control-error --fields=$fields  --binary=$binary \
        "tcp:localhost:$feedback_port;fields=$feedback_fields;binary=$feedback_binary" \
        --mode=fixed --proximity=0.1 --frequency=20 --past-endpoint --status --flush --verbose \
    | csv-from-bin $output_format --flush \
    | csv-eval --fields $output_fields --format $output_format \
        "time_diff=( feedback_t - datetime64('2015-01-01T00:00:00.000000') )/timedelta64(1,'s')" --full-xpath --flush \
    | tee output/output.csv \
    | name-value-from-csv $output_fields,time_diff --line-number --prefix output \
    | csv-quote --unquote --fields ,x --delimiter =


cat output/output.csv \
    | csv-paste - line-number \
    | csv-select --fields $output_fields "reached;equals=1" \
    | rev | cut -d, -f1 | rev \
    | name-value-from-csv index --line-number --prefix reached \
    | csv-quote --unquote --fields ,x --delimiter =
