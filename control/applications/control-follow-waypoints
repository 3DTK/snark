#!/bin/bash

scriptname=$( basename $0 )
source $( which comma-application-util )

function option_description
{
    cat <<EOF
--mode=[<mode>]; waypoint following mode (fixed or dynamic)
--steering=[<steering>]; steering mode (omni or skid)
--frequency=[<frequency>]; control frequency (default: $default_frequency); the rate at which $scriptname outputs wheel commands
--fields=[<fields>]; input fields (default: $default_target_fields)
--binary=[<format>]; binary format of input fields if input is binary
--feedback=[<feedback>]; feedback source, fields, and binary format if feedback is binary (default fields: $default_feedback_fields )
--cross-track-pid=[<cross_track_pid>]; pid parameters for cross-track errors (where <pid>=p,i,d[,threshold])
--heading-pid=[<heading_pid>]; pid parameters for heading errors (where <pid>=p,i,d[,threshold])
--reset; switch on resetting of pids upon reaching a waypoint
--proximity=[<proximity>]; a proximity value for deciding when a waypoint is reached (default: $default_proximity)
--output-fields; show output fields and exit
--output-format; show output format and exit
EOF
}

function usage
{
    cat >&2 <<EOF

    take waypoints and output wheel commands based on feedback

output:
    <extra_fields>,<command_fields>
    where <command_fields> is 'turn_rate,local_heading' (for steering=omni) or 'turn_rate' (for steering=skid)
    and <extra_fields> consists of any fields specified in the input with the default input fields stripped, e.g.
    --fields=x,y,heading_offset,speed,type --steering=omni -> output-fields=speed,type,$( control-command --steering=omni --output-fields )
    --fields=x,y,speed --steering=skid -> output-fields=speed,$( control-command --steering=skid --output-fields )

example:
    $scriptname --mode=fixed --steering=omni --fields=x,y,heading_offset,speed --binary=4d \\
        --feedback="tcp:localhost:12345;fields=t,x,y,yaw,yaw_rate;binary=t,4d" \\
        --cross-track-pid=1,2,3,0.1 --heading-pid=1,2,3,0.1 --proximity=0.1 --reset

options:
$( option_description | sed 's/^/    /g' )

EOF
    exit
}

function count_commas { echo -n $1 | sed 's/[^,]//g' | wc -c; }
function fields_and_format_are_consistent { local fields=$1 format=$2; (( $( count_commas $fields ) == $( count_commas $( csv-format expand <<< $format ) ) )) && return 0 || return 1; }
function extract_option { local what=$1 from=$2; echo "$from" | grep "$what=" 2>/dev/null | sed -E "s/.*;?($what=[^;]+);?.*/\1/g;s/$what=//g"; }
function compress_commas { sed -E 's/,+/,/g;s/(^,|,$)//g'; }
function add_xpath { local path=$1 fields=$2; csv-fields prefix --fields "x,y" --path "position" <<< $fields | csv-fields prefix --path $path; }

function bye
{
    pkill -P $$
    exit 1
}

trap bye INT TERM HUP

default_target_fields="x,y,heading_offset"
default_feedback_fields="t,x,y,yaw,yaw_rate"
declare -A target
declare -A feedback
default_proximity=0.05
default_frequency=20.0
reset=
declare -i binary_output

if (( $( comma_options_has --help "$@" ) || $( comma_options_has -h "$@" ) )); then usage; fi
comma_path_value_to_var --prefix=options < <( option_description | comma-options-to-name-value "$@" )

steering=$options_steering
if [[ -z "$steering" ]]; then echo "$scriptname: steering is not given" >&2; exit 1; fi

error_fields=$( control-error --output-fields )
error_format=$( control-error --output-format )
command_fields=$( control-command --steering=$steering --output-fields )
command_format=$( control-command --steering=$steering --output-format )

target[fields]=${options_fields:-$default_target_fields}
target[format]=$options_binary
feedback[fields]=$default_feedback_fields
feedback[format]=
if [[ -n "$options_feedback" ]]; then
    feedback[source]=$( sed 's/;.*//g' <<< "$options_feedback" )
    feedback_fields=$( extract_option fields "$options_feedback" )
    feedback_format=$( extract_option binary "$options_feedback" )
    [[ -n "$feedback_fields" ]] && feedback[fields]=$feedback_fields
    [[ -n "$feedback_format" ]] && feedback[format]=$feedback_format
fi

passed_fields=$( add_xpath target ${target[fields]} ),$( add_xpath feedback ${feedback[fields]} )
all_fields=$passed_fields,$error_fields,$command_fields
keep_target_fields=$( add_xpath target $( csv-fields clear --remove $default_target_fields <<< ${target[fields]} ) )
cut_fields=$( csv-fields clear --keep $keep_target_fields,$command_fields <<< $all_fields )
output_fields=$( compress_commas <<< $cut_fields )

if (( $( comma_options_has --output-fields "$@" ) )); then csv-fields prefix --basename <<< $output_fields; exit; fi

if [[ -z "${target[format]}" && -z "${feedback[format]}" ]]; then binary_output=0
elif [[ -n "${target[format]}" && -n "${feedback[format]}" ]]; then binary_output=1
else echo "$scriptname: input and feedback streams should be both ascii or both binary" >&2; exit 1; fi

if (( binary_output )); then
    if ! fields_and_format_are_consistent ${target[fields]} ${target[format]}; then echo "$scriptname: target fields and format are inconsistent ${target[fields]} ${target[format]}" >&2; exit 1; fi
    if ! fields_and_format_are_consistent ${feedback[fields]} ${feedback[format]}; then echo "$scriptname: feedback fields and format are inconsistent ${feedback[fields]} ${feedback[format]}" >&2; exit 1; fi
    passed_format=${target[format]},${feedback[format]}
    all_format=$passed_format,$error_format,$command_format
    output_format=$( csv-format expand <<< $all_format | csv-fields clear --mask $cut_fields | compress_commas )
fi

if (( $( comma_options_has --output-format "$@" ) )); then
    if (( ! binary_output )); then echo "$scriptname: failed to get output format since output is ascii" >&2; exit 1; fi
    echo $output_format
    exit
fi

mode=$options_mode
cross_track_pid=$options_cross_track_pid
heading_pid=$options_heading_pid
proximity=${options_proximity:-$default_proximity}
frequency=${options_frequency:-$default_frequency}
(( $( comma_options_has --reset "$@" ) )) && reset="--reset"

if [[ -z "$options_feedback" ]]; then echo "$scriptname: feedback source is not given" >&2; exit 1; fi
if [[ -z "$mode" ]]; then echo "$scriptname: mode is not given" >&2; exit 1; fi
if [[ -z "$cross_track_pid" ]]; then echo "$scriptname: cross-track pid is not given" >&2; exit 1; fi
if [[ -z "$heading_pid" ]]; then echo "$scriptname: heading pid is not given" >&2; exit 1; fi

control-error "${feedback[source]};fields=${feedback[fields]}${feedback[format]:+;binary=${feedback[format]}}" \
    --mode=$mode --fields=${target[fields]} ${target[format]:+--binary=${target[format]}} --proximity=$proximity --frequency=$frequency --past-endpoint --verbose --flush \
    | control-command --fields=$passed_fields,$error_fields ${passed_format:+--binary=$passed_format,$error_format} \
    --cross-track-pid=$cross_track_pid --heading-pid=$heading_pid --steering=$steering $reset --verbose --flush \
    | csv-shuffle --fields=$all_fields ${all_format:+--binary=$all_format} --output-fields=$output_fields --flush &

wait
