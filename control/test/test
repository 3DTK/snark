#!/bin/bash

function find_free_port { for(( port=1024; port < 65536; port++ )); do ! netstat -ltun | grep $port &>/dev/null && echo $port && return; done; }
function wait_for_success { for(( i=0; i<100; i++ )); do eval "$1" && return 0 || sleep 0.01; done; return 1; }
function clean
{
    pkill -P $$
    rm -f $input $feedback $output
    kill -9 $pid $socat_pid &>/dev/null
    return 0
}
function bye { clean; exit 1; }
trap bye INT TERM HUP

port=$( find_free_port )
input=/tmp/snark_control_error_input
feedback=/tmp/snark_control_error_feedback
output=/tmp/snark_control_error_output

rm -f $input $feedback $output
mkfifo $input
mkfifo $feedback
tail -F $input | control-error "tcp:localhost:$port;fields=t,x,y,,,,yaw;binary=t,6d" --proximity=0.01 --flush > $output & pid=$!
tail -F $feedback | socat -u - tcp-listen:$port,reuseaddr,fork & socat_pid=$!
wait_for_success "netstat -ltn | grep $port &>/dev/null"

function send_feedback
{
    local x y yaw
    IFS=, read x y yaw <<< $1
    echo -e "20121011T121314.123456,$x,$y,0,0,0,$yaw" | csv-to-bin t,6d > $feedback
}

output_line_count=0
function wait_for_new_output
{
    (( output_line_count++ ))
    wait_for_success "(( $( wc -l < $output ) == $output_line_count ))" && return 0
    echo "failed to get a new line in $output" >&2
    return 1
}

function test_feedback
{
    local lhs=$1
    local values=$2
    send_feedback $values
    wait_for_new_output && echo "$lhs=\"$( tail -n1 $output )\"" || exit 1
}

echo -e "1,0" > $input
test_feedback "basic/xtrack/zero" 0,0,0
test_feedback "basic/xtrack/positive" 0,0.1,0
test_feedback "basic/xtrack/negative" 0,-0.1,0
test_feedback "basic/heading/positive" 0,0,0.1
test_feedback "basic/heading/negative" 0,0,-0.1
send_feedback 1,0,0

clean
