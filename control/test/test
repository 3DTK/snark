#!/bin/bash

function find_free_port { for(( port=1024; port < 65536; port++ )); do ! netstat -ltun | grep $port &>/dev/null && echo $port && return; done; }

function wait_for_success
{
    local reps=10
    local dt=0.1
    for(( i=0; i<reps; i++ )); do
        eval "$1" && return 0 || sleep $dt
    done
    echo "condition '$1' has not been satisfied in the alloted $( bc -l <<< "$reps*$dt" ) seconds" >&2
    return 1
}

function bye
{
    pkill -P $$
    rm -f $input $output
    exec 3<&-
    kill -9 $pid &>/dev/null
    exit 1
}

trap bye INT TERM HUP

port=$( find_free_port )
input=/tmp/snark_control_error_input
output=/tmp/snark_control_error_output

rm -f $input $output
mkfifo $input
mkfifo $output

exec 3> >( socat -u - tcp-listen:$port,reuseaddr,fork )
tail -F $input | control-error "tcp:localhost:$port;fields=t,x,y,,,,yaw;binary=t,6d" --proximity=0.01 --verbose &
#|
    #while :; do IFS=, read wp_x wp_y cross_track_error heading_error; echo $cross_track_error $heading_error; done &

echo -e "1,0" > $input
echo -e "20121010T101010.123456,0,0,0,0,0,0" | csv-to-bin t,6d >&3
echo -e "20121010T101010.123456,0,0.1,0,0,0,0" | csv-to-bin t,6d >&3
echo -e "20121010T101010.123456,0,-0.1,0,0,0,0" | csv-to-bin t,6d >&3
echo -e "20121010T101010.123456,0,0,0,0,0,0.2" | csv-to-bin t,6d >&3
echo -e "20121010T101010.123456,0,0,0,0,0,-0.2" | csv-to-bin t,6d >&3
echo -e "20121010T101010.123456,1,0,0,0,0,0" | csv-to-bin t,6d >&3
echo -e "1,1" > $input
echo -e "20121010T101010.123456,1,0,0,0,0,1" | csv-to-bin t,6d >&3
echo -e "20121010T101010.123456,1,1,0,0,0,0" | csv-to-bin t,6d >&3

bye