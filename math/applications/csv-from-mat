#!/usr/bin/python

# This file is part of comma, a generic and flexible library
# Copyright (c) 2017 The University of Sydney
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
# 3. Neither the name of the University of Sydney nor the
#    names of its contributors may be used to endorse or promote products
#    derived from this software without specific prior written permission.
#
# NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE
# GRANTED BY THIS LICENSE.  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT
# HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED
# WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
# BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
# OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
# IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

import sys
import signal
import argparse
import comma.csv.format

def import_advice( module ):
    debian_pkg = {
        "scipy.io": "python-scipy",
        "numpy": "python-numpy"
    }
    preamble = "Install"
    if debian_pkg.has_key( module ):
        print "On debian/ubuntu install with \"apt-get install %s\"" % debian_pkg[ module ]
        preamble = "On other systems install"
    print "%s with \"pip install %s\"" % ( preamble, module )

try:
    import numpy
    import scipy.io
except ImportError as e:
    print "ImportError:", e
    module = e.args[0].split(' ')[-1]
    import_advice( module )
    sys.exit( 1 )


def message( msg, data=() ):
    msg = "csv-from-mat: %s" % msg
    print >> sys.stderr, msg % data


def bash_completion (parser):
    print " ".join(
        [ o for o in parser._option_string_actions.keys()
          if o != "--bash-completion" ])


def parse_args():
    description="""
extract variable from Matlab save file and return as csv
"""

    epilog="""
output format:
  If the variable given is a leaf node then the data in that node is output in
  csv-style ascii or binary. If it's higher than a leaf node then all variables
  from that point down are output in path-value form with the value in
  python-style ascii.

file format:
  Currently supports file format v7 and earlier, which is the default for all
  current versions of Matlab (including R2017a). Use the version option in the
  Matlab save command to force a version when saving. If v7.3 support is
  required then python library h5py can help, or possibly hdf5storage.

examples:
  {script_name} data.mat
  {script_name} data.mat foo.bar
  {script_name} data.mat --list
  {script_name} data.mat --list --path-separator /
  {script_name} data.mat foo --list
  {script_name} data.mat foo.bar --binary
  {script_name} data.mat foo.bar --output-format
""".format( script_name=sys.argv[0].split('/')[-1] )

    fmt=lambda prog: argparse.RawDescriptionHelpFormatter( prog, max_help_position=50 )

    parser = argparse.ArgumentParser( description=description,
                                      epilog=epilog,
                                      formatter_class=fmt )

    parser.add_argument( "input_file", nargs="?", help="path to Matlab save file" )
    parser.add_argument( "variable", nargs="?", help="variable to extract from save file" )

    parser.add_argument( '--bash-completion', action='store_true', help=argparse.SUPPRESS )
    parser.add_argument( '--binary', action='store_true', help="output in binary (default is ascii)" )
    parser.add_argument( '--csv', action='store_true', help="output as csv (only for non-compound variables)" )
    parser.add_argument( '--list', action='store_true', help="list variables in given file" )
    parser.add_argument( '--output-format', action='store_true', help="show format of data" )
    parser.add_argument( '--path-separator', metavar="<char>", default=".", help="separator for input and output of variable paths (default=.)" )

    args = parser.parse_args()

    if args.bash_completion:
        bash_completion( parser )
        sys.exit( 0 )

    return args


def reset_signals():
    # Reset SIGPIPE and SIGINT to their default OS behaviour.
    # This stops python dumping a stack-trace on ctrl-c or broken pipe.
    signal.signal( signal.SIGPIPE, signal.SIG_DFL )
    s = signal.signal( signal.SIGINT, signal.SIG_DFL )
    # but don't reset SIGINT if it's been assigned to something other
    # than the Python default
    if s != signal.default_int_handler:
        signal.signal( signal.SIGINT, s )


def is_compound( variable ):
    try:
        comma.csv.format.from_numpy( variable.dtype )
        return False
    except ( AttributeError, ValueError ):
        return True


def step_down( mat ):
    if mat.dtype == numpy.dtype('O'): # sometimes there's extra nesting
        mat = mat[0][0]
    if not isinstance( mat, numpy.ndarray ):
        raise ValueError
    return mat


def print_tree( path, tree, sep, with_values ):
    if is_compound( tree ):
        # at the top level, mat is a dictionary, but as we drill down
        # it turns into nested numpy.ndarray objects
        keys = ( [ i for i in tree.keys() if i[0] != '_' ]
                 if isinstance( tree, dict )
                 else tree.dtype.fields.keys() )
        for k in keys:
            try:
                d = step_down( tree[k] )
            except ValueError:
                return
            print_tree( k if path is None else "%s%s%s" % ( path, sep, k ),
                        d, sep, with_values )
    else:
        if with_values:
            print "%s=%s" % ( path, tree.tolist() )
        else:
            print path


def main():
    reset_signals
    args = parse_args()

    try:
        mat = scipy.io.loadmat( args.input_file )
    except IOError as e:
        message( "%s \"%s\"", ( e.strerror, args.input_file ))
        return
    except NotImplementedError as e:
        message( "support for Matlab file format v7.3 is not yet implemented (see help)" )
        return

    if args.variable:
        for v in args.variable.split( args.path_separator ):
            try:
                mat = step_down( mat[ v ] )
            except ( KeyError, ValueError ):
                message( "variable \"%s\" does not exist", args.variable )
                return

    if args.list:
        print_tree( args.variable, mat, args.path_separator, False )
        return

    compound_variable = is_compound( mat )

    if args.output_format:
        if compound_variable:
            if args.variable:
                message( "%s is not a data array", args.variable )
            else:
                message( "--output-format requires a non-compound variable" )
        else:
            print "%s%s" % ( mat.shape[1], comma.csv.format.from_numpy( mat.dtype ))
        return

    if args.binary:
        if compound_variable:
            message( "only non-compound variables can be output in binary" )
        else:
            mat.tofile( sys.stdout )
    else:
        if args.csv:
            if compound_variable:
                message( "only non-compound variables can be output in csv format" )
            else:
                for t in mat:
                    t.tofile( sys.stdout, "," )
                    print
        else:
            print_tree( args.variable, mat, args.path_separator, True )


if __name__ == '__main__':
    main()
