#!/bin/bash

name=$( basename $0 )
verbose="--verbose"
source $( which comma-application-util )
source $( which comma-process-util )

function usage
{
    cat >&2 <<END
publish asd sensor data on demand
usage: asd-publishd [<config>]
    config: config file json; defualt /usr/local/etc/shrimp.json

END
    exit
}

function kill_socat_spawns { pkill -P $socat_pid; }

function bye
{
    kill_socat_spawns
    pkill -P $$
    wait
    rm -f $socket
    exit 1
}

trap bye INT TERM HUP


for arg in $@ ; do if [[ "$arg" == "--help" || "$arg" == "-h" ]] ; then usage; fi; done
config="$1"
if [[ -z "$config" ]]; then config="/usr/local/etc/shrimp.json"; fi
if [[ -s "$config" ]]; then echo "$name: reading $config" >&2; else echo "$name: config file not found: $config" >&2; exit 1; fi

comma_path_value_to_var --prefix=config < <(cat "$config" | name-value-get asd; echo ) 
port=$config_port
size=$config_size
command="echo A, | asd-control $config_device --raw --timestamp --acquire "

if [[ -z "$port" ]]; then echo "$name: port is not given" >&2; exit 1; fi
if [[ -z "$size" ]]; then echo "$name: size is not given" >&2; exit 1; fi
if [[ -z "$command" ]]; then echo "$name: command is not given" >&2; exit 1; fi

state="begin"
function check_connection()
{
    if echo "V," | asd-control $config_device --strict $verbose >&2 ; then
        state="init"
    else
        sleep 10
    fi
}

# function query_data()
# {
#     if echo "A," | asd-control $config_device --strict $verbose >&2 ; then
#         state="run";
#     else
#         state="init";
#         echo "$name: acquire data failed"
#     fi
# }

function init_device()
{
    #eval "$command" >&2
    if echo "RESTORE,1" | asd-control "$config_device" --strict $verbose >&2 ; then
        echo "ABORT," | asd-control "$config_device" $verbose >&2 & abort_pid=$!
        sleep 10;
        kill $abort_pid
        state=run
    else
        #something didn't work
        state=begin
        sleep 10
    fi
}

daemon=${command%% *}
if [[ ! -x $( which $daemon ) ]]; then echo "$name: daemon '$daemon' is not found" >&2; exit 1; fi

socket=/tmp/$( basename $daemon )$$
rm -f $socket

zero_options="-b 16 --size $size"
exec_options=
if [[ "$size" == 0 ]]; then
    zero_options=
    exec_options=,pty
fi

socat -U tcp4-listen:$port,reuseaddr,fork exec:"zero-cat $zero_options 'ipc://$socket'"$exec_options 2>/dev/null &
socat_pid=$!

while [[ $state != "run" ]]; do
    echo "$name: state: $state"
    case "$state" in
        begin) check_connection ;;
#        query) query_data ;;
        init) init_device ;;
    esac;
done

echo "$name: running..." >&2

function daemonize
{
    trap - INT TERM # unsetting these traps is necessary since trap handling by bye interferes with comma_execute_and_wait trap handling
    trap 'kill_socat_spawns' HUP
    comma_execute_and_wait --group "bash -c eval \"$1\""
}

daemon_pid=
while :; do
    if lsof -n -i TCP:$port | grep ESTABLISHED &>/dev/null; then
        if [[ -z "$daemon_pid" ]]; then
            daemonize "$command | zero-cat --publish $zero_options ipc://$socket" &
            daemon_pid=$!
        fi
        stray_socat_pids=$( lsof -n -i TCP:$port | grep CLOSE_WAIT | grep socat | tr -s ' ' |  cut -d ' ' -f2 )
        kill $stray_socat_pids &>/dev/null
    else
        if [[ -n "$daemon_pid" ]]; then
            kill $daemon_pid &>/dev/null
            wait $daemon_pid &>/dev/null
            daemon_pid=
        fi
    fi
    sleep 0.1
done

